[toc]

# 1、*Project1: implement the native birthday attack of reduced SM3-实施简化的SM3生日攻击*

## 一、SM3国密算法 




### 1、概要：
SM3是我国采用的一种密码散列函数标准，由国家密码管理局于2010年12月17日发布。相关标准为“GM/T 0004-2012 《SM3密码杂凑算法》”。
在商用密码体系中，SM3主要用于数字签名及验证、消息认证码生成及验证、随机数生成等，其算法公开。据国家密码管理局表示，其安全性及效率与SHA-256相当。
在信息安全中，有许多重要的应用，都使用了密码散列函数来实现，例如数字签名，消息认证码



### 2、术语和定义：
#### 2.1：
* **比特串  bit string**
* 由0和1组成的二进制数字序列。

#### 2.2 ：
* **大端  big-endian**
* 数据在内存中的一种表示格式，回顶左边为高有效位，右边为低有效位。数的高阶字节放在存储器的低地址，数的低阶字节放在存储器的高地址。

#### 2.3：
* **消息  message**
* 任意有限长度的比特串。本文本中消息作为杂凑算法的输入数据。

#### 2.4：
+ **杂凑值  hash value**
+ 杂凑算法作用于消息后输出的特定长度的比特串。本文本中的杂凑值长度为256比特。

#### 2.5：
* **字  word**
* 长度为32的比特串。



### 3、符号：
 下列符号适用于本文本。
 * $ABCDEFGH$: 8个字寄存器或它们的值的串联

 * $B^{(i)} $: 第i个消息分组

 * $ CF$: 压缩函数

 * $FF_j$: 布尔函数，随j的变化取不同的表达式

 * $GG_j$: 布尔函数，随j的变化取不同的表达式

 * $IV$: 初始值，用于确定压缩函数寄存器的初态

 * $P_0$: 压缩函数中的置换函数

 * $P_1$: 消息拓展中的置换函数

 * $T_j$: 常量，随j的变化取不同的值

 * $ m$: 消息

 * $ m’$：填充后的消息

 * $mod$: 模运算

 * $∧$: 32比特与运算

 * $∨$: 32比特或运算

 * $⊕$: 32比特异或运算

 * $¬ $: 32比特非运算

 * $ +$: mod2的32次方算术加运算

 * $\ll k$: 循环左移k比特运算

 * $←$: 左向赋值运算符



### 4、常数与函数：

#### 4.1 初始值

* $IV=7380166f\ 4914b2b9\ 172442d7\ da8a0600\ a96f30bc\ 163138aa\ e38dee4d\  b0fb0e4e$

#### 4.2 常量

* $$
  T_j=\begin{cases} 79cc4519，0\leq j\leq 15 &&&\\7a879d8a，16\leq j\leq 63\end{cases}&
  $$
  
* 

#### 4.3 布尔函数

* $$
  &&&&FF_j=\begin{cases} X\oplus Y\oplus Z ，0\leq j\leq 15 \\ (X\wedge Y)\vee (X\wedge Z)\vee (Y\wedge Z)，16\le j\le63\end{cases}
  $$

* $$
  GG_j=\begin{cases}X\oplus Y\oplus Z，0\le j\le15\\(X\wedge Y)\vee(¬X∧Z)， 16\le j ≤ 63\end{cases}
  $$

  ​												 式中$X$为字

#### 4.4 置换函数

* $ P_0(X)=X\oplus(X\lll9)\oplus(X\lll17)$
* $P_1(X)=X\oplus(X\lll15)\oplus (X\lll23)$
* 式中$X$为字



### 5 算法描述:

#### 5.1 概述
* 对长度为$l(l<2^{64})$比特的消息$m$,SM3杂凑算法经过填充和迭代压缩，生成杂凑值，杂凑值长度为256比特。

  

#### 5.2 填充

* 假设消息$m$的长度为$l$比特。首先将比特”$1$“添加到消息的末尾,再添加$k$个“$0$”,$k$是满足$l+1+k=448mod512$的最小的非负整数。然后再添加一个64位的比特串，该比特串式长度$l$的二进制表示。填充后的消息$m'$的比特长度为512的倍数。

  ​	例如：对消息01100001 01100010 01100011，其长度为$l$=24,经填充得到比特串：

  ​				 $01100001\ 01100010\ 01100011\ \overbrace{ 00···00}^{423比特}\ \overbrace{\underbrace{00···011000}_{l的二进制表示}}^{64比特}$ 

#### 5.3 迭代压缩
##### 5.3.1 迭代过程

* 将填充后的消息$m'$按512比特进行分组：$m'=B^{(0)}B^{(1)}···B^{(n-1)}$

​		其中$n=(l+k+65)/512$。

​		对$m'$按下列方式迭代：

​		$FOR \ \ i=0\ \ TO\ \ n-1 $

​				$V (i+1) = CF(V^{(i)} , B^{(i)} )$

​		**$ENDFOR$**

​		其中$CF$是压缩函数，$V^{(0)}$为256比特初始值$IV$, $B^{(i)}$为填充后的消息分组，迭代压缩的结果为$V^{(n)}$

##### 5.3.2 消息拓展

* 将消息分组$B^{(i)}$按以下方法拓展生成132个字$W_0, W_1,·· · , W_67, W'_0 , W'_1 , · · · , W'_{63}$,用于压缩函数$CF$

  $a)$: 将消息分组$B^{(i)}$划分为16个字$W_0,W_1,· ·W_{15} $。

  $b)$: $FOR\ \ j=16\ \ TO\ \ 67$

  ​		  $W_j\leftarrow P_1(W_{j-16}\oplus W_{j-9}\oplus(W_{j-3}\lll15))\oplus(W_{j-13}\lll 7)\oplus W_{j-6} $ 	

  ​	 $ENDFOR$
  
  $c)$: $FOR\ \ j=0\ \ TO\ \ 63$

​			     $W'_j = W_j⊕W_{j+4}$

​		   $ENDFOR$
##### 5.3.3 压缩函数

* 令$A,B,C,D,E,F,G,H$为字寄存器，$SS1,SS2,TT1,TT2$为中间变量，压缩函数$V^{i+1}=$$CF(V^{(i)},B^{(i)}),0\le i\le n-1$。计算过程描述如下：

  $ABCDEFGH \leftarrow V^{(i)}$

  $ FOR\ \ j=0\ \ TO \ \ 63$

  ​		$SS1\leftarrow ((A\lll 12)+E+(T_j \lll j))\lll7$
  
  ​		$SS2\leftarrow SS1\oplus (A\lll12)$
  
  ​		$TT1\leftarrow FF_j (A,B,C)+D+SS2+W'_j$
  
  ​		$TT2\leftarrow GG_j(E,F,G)+H+SS1+W_j$
  
  ​		$D\leftarrow C$
  
  ​		$C\leftarrow B\lll 9$
  
  ​		$B\leftarrow A$
  
  ​		$A\leftarrow TT1$
  
  ​		$H\leftarrow G$
  
  ​		$G\leftarrow F\lll 19$
  
  ​		$F\leftarrow E$
  
  ​		$E\leftarrow P_0{(TT2)} $
  
  $ENDFOR$
  
  $V^{(i+1)}\leftarrow ABCDEFGH\oplus V^{(i)}$
  
  其中，字的存储为大端(big-endan)格式。
  
##### 5.4 杂凑值

* $ABCDEFGH\leftarrow V^{(n)}$

​		输出256比特的杂凑值$y=ABCDEFGH$。



## 二、生日攻击



### 1、哈希碰撞
* 两个不同的输入，经过哈希算法后，得到了同样的哈希值，就叫做哈希碰撞。由于通常的哈希算法中，哈希值的空间远小于输入的空间，这就意味着信息熵有丢失。一个空间较大的集合(输入)通过哈希算法映射到一个空间较小的集合(哈希值)，必然会造成多个输入映射到一个哈希值上，这就是所谓的哈希碰撞。这就是说当输入的可能性被完全枚举时，一定会产生哈希碰撞。
避免哈希碰撞的主要手段是，根据输入集合的数量级，选取输出合适哈希值长度的哈希函数，将哈希碰撞的概率降为“几乎不可能”。



### 2、生日悖论

* 生日悖论：如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。对于60人以上，这种概率要大于99%。70人为99%，严格意义上，这并不是一个悖论，称之为悖论是由于跟人们的常识相悖。

  所以所有人生日都不相同的概率是：

  

  ​			$\frac{365}{365}·\frac{364}{365}·\frac{363}{365}···\frac{365-n+1}{365}$

  

  那么，n个人中至少两个人生日相同的概率就是：

  ​	

  ​			$1-\frac{365}{365}·\frac{364}{365}·\frac{363}{365}···\frac{365-n+1}{365}$

  

  所以当n=23时，概率为0.507;当n=100时，概率为0.999999692751072。



### 3、生日攻击结论

* Hash函数的输出长度为m,且分布均匀，则所有Hash值得所有可能为$2^m$,现假设尝试X次，选择不同的输入，得出的Hash值不同，即不发生碰撞；超过X次即发生碰撞（称X为碰撞阀值），则对于尝试t（t<X）次时没有碰撞的概率为：

  ​	$\begin{align*}P(t<X) &= (1-\frac{1}{2^m})(1-\frac{2}{2^m})(1-\frac{3}{2^m})···(1-\frac{t-1}{2^m}) \\&=\prod_{i=1}^{t-1}{(1-\frac{i}{2^m})}\\ &\approx\prod_{i=1}^{t-1}(e^{-\frac{i}{2^m}})\ \ \ \ \ \ \ (1-\frac{i}{2^m}\thicksim e^{\frac{-i}{2^m}}) \\&=e^{-\frac{t(t-1)}{2^{m+1}}}\end{align*}$

* 而X的数学期望$E(X)$:
  $$
  \begin{align}E(X)&=\sum _{t-1}^d \times P(X=t)
  \\&=\sum_{t=1}^dt \times(P(X>t-1)-P(X>t))
  \\&=\sum_{t=1}^dt\times(P(X>t-1)-\sum_{t=1}^dt\times P(X>t)
  \\&=\sum_{t=0}^{d-1}(t+1)P(X>t)-\sum_{t=1}^dt\times P(X>t))
  \\&\approx \sum_{t-0}^dP(X>t)
  \\&\approx \sum_{t=0}^\infty e^{{-{t^2}/2^{m+1}}}
  \\&\approx \int_0^\infty e^{-t^2/2^{m+1}}dx
  \\&= \sqrt{\pi 2^m/2}
  \end{align}
  $$
  这里$\sqrt{\frac{\pi2^m}{2}}\approx2^{\frac{m}{2}}$,即平均尝试超过$2^\frac{m}{2}$次选择明文攻击，就可以产生一次碰撞。



## 三、运行结果如下 

![image-20230804153110267](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804153110267.png)

* 对于Hash函数，这里如果输出为32位，则大约我们只需要搜索$2^{32/2=16}$次，即这里我们只需要搜索前16bit，就能以50%的概率找到碰撞





# 2、*Project2: implement the Rho method of reduced SM3-实现简化的SM3中Rho的实现方法*

## 一、Rho算法

* 原理：寻找两个元素$x_1$与$x_2$,满足$x_1 \neq x_2modn,x_1 =x_2modp$,利用$gcd(x_1-x_2,n)$计算n的因子p

* 如下图：

  ![image-20230804205737956](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804205737956.png)

* 代码如下：

```python
def Rho():
    s=[]
    start=1
    rho=0
    for i in range(10000):
        s.append(rho)
        if(rho<1000):
            rho=2*rho+1
        else:
            rho=start+1
            start+=1
    return s
```

* 主要思想：
  1. 定义了一个空列表`s`，用于存储生成的整数。
  2. 使用`start`和`rho`两个变量来控制不同条件下的值的生成。
  3. 使用`for`循环进行10000次迭代，每次迭代将当前的`rho`值添加到列表`s`中。
  4. 根据`rho`的值选择不同的计算方式来生成下一个`rho`值。
  5. 返回生成的整数列表`s`



## 二、运行结果

![image-20230804205038161](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804205038161.png)

找到前16bit的碰撞。



# *3、Project4: do your best to optimize SM3 implementation (software)-尽力优化SM3的实现（软件）*

## 一、优化原理

* 这里我主要采用了循环展开，不过经过我的实验，我发现循环展开优化的很少

* 主要优化代码，如下：

  ```python
  def CF(V,B):
      W_ = []
      W = cut(B, 32)  
      for j in range(16):
          W[j] = int(W[j], 2)
      for j in range(16, 68):
          temp = P1(W[j - 16] ^ W[j - 9] ^ leftshift(W[j - 3], 15)) ^ (leftshift(W[j - 13], 7)) ^ W[j - 6]
          W.append(temp)
      for j in range(64):
          tmp = W[j] ^ W[j + 4]
          W_.append(tmp)
  ```

  这里可以通过先把值计算出来,得到temp中间变量,然后储存起来,

  如果是

  ```python
  W.append(P1(W[j - 16] ^ W[j - 9] ^ leftshift(W[j - 3], 15)) ^ (leftshift(W[j - 13], 7)) ^ W[j - 6])
  ```

  在每次循环中都会计算前两个数,会造成重复.可以用变量temp进行储存 

* 主要是这后两个for循环可以进行循环展开。

* 优化如下：

  ```python
  W.extend([0]*(68-16))
  for j in range(16,17):
      W[j] = P1(W[j-16] ^ W[j-9] ^ leftshift(W[j-3], 15)) ^ (leftshift(W[j-13], 7)) ^ W[j-6]
      W[j+1] = P1(W[j-15] ^ W[j-8] ^ leftshift(W[j-2], 15)) ^ (leftshift(W[j-12], 7)) ^ W[j-5]
      W[j+2] = P1(W[j-14] ^ W[j-7] ^ leftshift(W[j-1], 15)) ^ (leftshift(W[j-11], 7)) ^ W[j-4]
  for j in range(19,20):
      W[j] = P1(W[j-16] ^ W[j-9] ^ leftshift(W[j-3], 15)) ^ (leftshift(W[j-13], 7)) ^ W[j-6]
      W[j+1] = P1(W[j-15] ^ W[j-8] ^ leftshift(W[j-2], 15)) ^ (leftshift(W[j-12], 7)) ^ W[j-5]
      W[j+2] = P1(W[j-14] ^ W[j-7] ^ leftshift(W[j-1], 15)) ^ (leftshift(W[j-11], 7)) ^ W[j-4]
      ····
  for j in range(64,65):
      W[j] = P1(W[j - 16] ^ W[j - 9] ^ leftshift(W[j - 3], 15)) ^ (leftshift(W[j - 13], 7)) ^ W[j - 6]
      W[j + 1] = P1(W[j - 15] ^ W[j - 8] ^ leftshift(W[j - 2], 15)) ^ (leftshift(W[j - 12], 7)) ^ W[j - 5]
      W[j + 2] = P1(W[j - 14] ^ W[j - 7] ^ leftshift(W[j - 1], 15)) ^ (leftshift(W[j - 11], 7)) ^ W[j - 4]
  W[67] = P1(W[51] ^ W[58] ^ leftshift(W[64], 15)) ^ (leftshift(W[54], 7)) ^ W[61]
  ```

  这里可以三个三个的循环展开，但是不能如下一样循环展开：

  ```python
  W.extend([0]*(68-16))
  W[16] = P1(W[0] ^ W[7] ^ leftshift(W[13], 15)) ^ (leftshift(W[3], 7)) ^ W[10]
  W[17] = P1(W[1] ^ W[8] ^ leftshift(W[14], 15)) ^ (leftshift(W[4], 7)) ^ W[11]
  W[18] = P1(W[2] ^ W[9] ^ leftshift(W[15], 15)) ^ (leftshift(W[5], 7)) ^ W[12]
  W[19] = P1(W[3] ^ W[10] ^ leftshift(W[16], 15)) ^ (leftshift(W[6], 7)) ^ W[13]
  ···
  W[64] = P1(W[48] ^ W[55] ^ leftshift(W[61], 15)) ^ (leftshift(W[51], 7)) ^ W[58]
  W[65] = P1(W[49] ^ W[56] ^ leftshift(W[62], 15)) ^ (leftshift(W[52], 7)) ^ W[59]
  W[66] = P1(W[50] ^ W[57] ^ leftshift(W[63], 15)) ^ (leftshift(W[53], 7)) ^ W[60]
  W[67] = P1(W[51] ^ W[58] ^ leftshift(W[64], 15)) ^ (leftshift(W[54], 7)) ^ W[61]
  ```

* 这是因为一开始我们只存储了$W[0]-W[15]$的值，如果全部都循环展开，会造成后面的值在等待前面W[j]的运算。但是当我们计算三个W[j]值时，就会保证此时都以储存这个值。所以三个三个的for循环展开，只需要18次运算，即17次for循环运算和最后一个W[67]的计算。

* 后面一个for循环优化：

  ```python
  	W_.append(W[0] ^ W[4])
    	W_.append(W[1] ^ W[5])
    	W_.append(W[2] ^ W[6])
    	W_.append(W[3] ^ W[7])
    	W_.append(W[4] ^ W[8])
    	···
    	W_.append(W[60] ^ W[64])
      W_.append(W[61] ^ W[65])
      W_.append(W[62] ^ W[66])
      W_.append(W[63] ^ W[67])
  
  ```
  
  这个可以全部循环展开，因为上一步已经把所有的W[j]值计算完成了。
  
  
## 二、运行结果 

  以下是几种运行结果图：

* 1. 没有加for循环展开：

  ![image-20230804220828598](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804220828598.png)

* 2. 只有最后一个for循环展开：

     ![image-20230804220953607](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804220953607.png)
  
* 3. 最后两个循环展开：
  ![image-20230804221051630](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804221051630.png)






# *4、Project5: Impl Merkle Tree following RFC6962-根据RFC6962实现Merkele树*

## 一、Mekle Tree原理

* Merkle tree看起来像是二叉树，是一个满二叉树（每一个层的结点数都达到最大值的二叉树），一棵Merkle树的结构如下：

![image-20230804210954258](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804210954258.png)

* 红色的是根结点，灰色的是非叶子结点，黄色的是叶子结点。叶子结点的数值是直接根据数据块的值与0作为参数，经过Hash运算得来的，而灰色结点的值是以两个孩子结点的hash值作为输入，经过Hash运算得来的。

* 一棵Merkle树有如下特点：

  1. 叶子结点的值是实际数据块的Hash值。

  2. 每个非叶子结点的值，都是孩子结点的Hash值。根结点称为Merkle根

  3. 如果树是二叉树的话，称为二叉Merkle树，且二叉Merkle树一定是满二叉树（奇数叶子凑成偶数个

  4. 如果出现需要处理的数据块是奇数个，只需要把这些数据块中的任意一个复制一份凑成偶数个就行，一般选择复制最后一个块。
  
     

## 二、RFC6962

* 1. RFC 6962，全名为"Certificate Transparency"，是由IETF（Internet Engineering Task Force）制定的一个标准。它旨在提供一种公开透明的方式来监测和验证TLS/SSL证书的签发情况。该规范于2013年发布，目的是解决现有的证书系统中可能存在的安全问题和潜在的信任问题。

* 2. RFC 6962规范要求证书颁发机构（CA）必须将所签发的证书提交到一个公共的、可检索的日志服务器上。这些日志服务器记录了所有已发布的TLS/SSL证书，包括证书内容、签发时间等详细信息，并且可以被任何人查询和检查。

* 3. 通过证书透明性，用户和系统可以验证证书是否被正确签发，避免恶意签发的伪造证书的风险。此外，当证书发生更改或撤销时，可以及时进行监测和通知，提高证书系统的安全性和透明度



## 三、运行结果：

![image-20230804180852680](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804180852680.png)





# *4、Project9: AES / SM4 software implementation-实现AES或者SM4的软件实现*

## 一、SM4国密算法

### 1、概要

* 2012年3月，国家密码管理局正式公布了包含SM4分组密码算法在内的《祖冲之序列密码算法》等6项密码行业标准。与DES和AES算法类似，SM4算法是一种分组密码算法。其分组长度为128bit，密钥长度也为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构，以字（32位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。SM4有很高的灵活性，所采用的S盒可以灵活地被替换，以应对突发性的安全威胁。算法的32轮迭代采用串行处理，这与AES中每轮使用代换和混淆并行地处理整个分组有很大不同。

  

### 2、密钥处理
#### 2.1 术语说明

* 加密密钥，SM4算法的加密密钥长度为128比特，将其分为四项，其中每一项都为为32位的字。表示为：

  $MK=(MK_0,MK_1,MK_2,MK_3)$

* 系统参数，其中每一项都为32位的字，表示为：

  $FK=(FK_0,FK_1,FK_2,FK_3)=(0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc)$

* 固定参数，用于密钥拓展算法。其中每一项都为32位的字。表示为：

  $CK=(CK_0,CK_1,···,CK_{31})$

* 轮密钥，其中每一项都为32位的字，轮密钥由加密密钥通过密钥拓展算法生成。表示为：

  $(Rk_0,Rk_1,\cdots,Rk_{31})$
  
  

#### 2.2 密钥拓展算法
将密钥的每个字分别与系统参数的每个字做异或运算得到$(K_0,K_1,K_2,K_3 )$，再将得到的后3个字与固定参数$CK_0$做异或运算后进行函数T运算得到值$C$,最后将函数T运算得到的$C$与$K_0$做异或运算就得到了第一轮的子密钥，也是下一轮密钥运算的$K_4$。

第一步：密钥与系统参数异或：

$(K_0,K_1,K_2,K_3)=(MK_0\oplus FK_0,MK_1\oplus FK_1,MK_2\oplus FK_2,MK_3\oplus FK_3 )$

  第二步：获取子密钥：

$Rk_i=K_{i+4}=K_i\oplus T'(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_i )$

其中$i=0,1,2,3,\cdots 31$用于生成共32个轮密钥。$T'$变化与加密算法轮函数中的变化除线性变化$L$不同外，其他相同。$T'$变换中的线性变换$L’$为

$L'(B)=B\oplus (B\lll13)\oplus (B\lll23)$



### 3、明文处理

#### 3.1 轮函数

1) 将128bit的明文分成4个32bit的字$X_1,X_2,X_3,X_4$

2) $X_{i+4}=X_i\oplus T(X_{i+1}\oplus X_{i+2}\oplus X_{i+3}\oplus RK_i)$给出，其中$i=0,1,2,3,\cdots 31$。进行32轮的操作
3) 最后一轮输出为$(X_{32},X_{33},X_{34},X_{35})$,再经过逆序，得到了密文$(X_{35},X_{34},X_{33},X_{32})$。



#### 3.2 $T$函数

SM4算法的合成置换$T$是$F_2^{32}\rightarrow F_2^{32}$的可逆置换。$T$置换是由一个非线性变换$\tau$和一个线性扩散变换$L$复合而成

，即$T(·)=L(\tau(·))$。



#### 3.3 $\tau $函数

非线性变换$ \tau$由四个S盒并行组成，设变换$ \tau $的输入$A=(a_0，a_1,a_2,a_3)\in (F_2^{8})^4$,输出是$B=(b_0,b_1,b_2,b_3)\in (F_2^8)^4$,则$(b_0,b_1,b_2,b_3)=(S(a_0),S(a_1),S(a_2),S(a_3))$。S盒详见下表：

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | a    | b    | c    | d    | e    | f    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | d6   | 90   | e9   | fe   | cc   | e1   | 3d   | b7   | 16   | b6   | 14   | c2   | 28   | fb   | 2c   | 05   |
| 1    | 2b   | 67   | 9a   | 76   | 2a   | be   | 04   | c3   | aa   | 44   | 13   | 26   | 49   | 86   | 06   | 99   |
| 2    | 9c   | 42   | 50   | f4   | 91   | ef   | 98   | 7a   | 33   | 54   | 0b   | 43   | ed   | cf   | ac   | 62   |
| 3    | e4   | b3   | 1c   | a9   | c9   | 08   | e8   | 95   | 80   | df   | 94   | fa   | 75   | 8f   | 3f   | a6   |
| 4    | 47   | 07   | a7   | fc   | f3   | 73   | 11   | ba   | 83   | 59   | 3c   | 19   | e6   | 85   | 4f   | a8   |
| 5    | 68   | 6b   | 81   | b2   | 71   | 64   | da   | 8b   | f8   | eb   | 0f   | 4b   | 70   | 56   | 9d   | 35   |
| 6    | 1e   | 24   | 0e   | 5e   | 63   | 58   | d1   | a2   | 25   | 22   | 7c   | 3b   | 01   | 21   | 78   | 87   |
| 7    | d4   | 00   | 46   | 57   | 9f   | d3   | 27   | 52   | 4c   | 36   | 02   | e7   | a0   | c4   | c8   | 9e   |
| 8    | ea   | bf   | 8a   | d2   | 40   | c7   | 38   | b5   | a3   | f7   | f2   | cd   | f9   | 61   | 15   | a1   |
| 9    | e0   | ae   | 5d   | a4   | 9b   | 34   | 1a   | 55   | ad   | 93   | 32   | 30   | f5   | 8c   | b1   | e3   |
| a    | 1d   | f6   | e2   | 2e   | 82   | 66   | ca   | 60   | c0   | 29   | 23   | ab   | 0d   | 53   | 4e   | 6f   |
| b    | d5   | db   | 37   | 45   | de   | fd   | 8e   | 2f   | 03   | ff   | 6a   | 72   | 6d   | 6c   | 5b   | 51   |
| c    | 8d   | 1b   | af   | 92   | bb   | dd   | bc   | 7f   | 11   | d9   | 5c   | 41   | 1f   | 10   | 5a   | d8   |
| d    | 0a   | c1   | 31   | 88   | a5   | cd   | 7b   | bd   | 2d   | 74   | d0   | 12   | b8   | e5   | b4   | b0   |
| e    | 89   | 69   | 97   | 4a   | 0c   | 96   | 77   | 7e   | 65   | b9   | f1   | 09   | c5   | 6e   | c6   | 84   |
| f    | 18   | f0   | 7d   | ec   | 3a   | dc   | 4d   | 20   | 79   | ee   | 5f   | 3e   | d7   | cb   | 39   | 48   |

1） 经过后3个字与固定参数异或后，得到的值A也为32位的字

2）将A拆分为4个8bit的字节进行S盒变换。该S盒是一个固定的8bit输入8bit输出的置换

注：输入的前4bit组成行标，后4bit组成列标



#### 3.4 $L$函数

非线性变换$ \tau $的输出是线性变换$L$的输入，设$L$的输入为$B\in F_2^{32}$,输出为$C\in F_2^{32}$,则

$C=L(B)=B\oplus(B\lll 2)\oplus (B\lll10)\oplus (B\lll 18)\oplus (B\lll24)$,其中$\lll$表示循环左移。



## 二、运行结果

![image-20230804173238724](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804173238724-1691141571965-1.png)





# *6、Project19: forge a signature to pretend that you are Satoshi-伪造签名以假冒Satoshi*

## 一、Secp256k1椭圆曲线签名算法



### 1、介绍

* Secp256k1为基于Fp有限域上的椭圆曲线，由于其特殊构造的特殊性，其优化后的实现比其他曲线性能上可以特高30％，有明显以下两个优点：

​		1）占用很少的带宽和存储资源，密钥的长度很短。

​		2）让所有的用户都可以使用同样的操作完成域运算



### 2、算法

#### 2.1 **椭圆曲线数字签名算法（ECDSA）**

​	**用户的密钥对：**

​	$(d,Q)$

​	待签名的信息：$M$

​	签名：

​	$Signature(M)=(r,s)$



#### 2.2 **签名过程**

1. 根据ECC算法随机生成一个密钥对

   $(k,R),R=(xR,yR)$

2. 令

   $r=xRmodn$

   如果r=0，则返回步骤1

3. 计算

   $H=Hash(M)$

4. 按照数据类型转换规则,将H转化为一个big-endian的整数e

5. $s=k^{-1}(e+rd)modn$

   若s=0,则返回步骤1

6. 输出的$S=(r,s)$即为签名

   

#### 2.3 验证过程

​	1. 计算

​		$H=Hash(M)$

​	2. 按照数据类型转化规则,将H转化为一个big-endian的整数e

​	3. 计算

​		$u_1=es^{-1}modn,u_2=rs^{-1}modn$

​	4. 计算

​		$R=(xR,yR)=u_1G+u_2Q$

​	如果R=零点,则验证该签名无效

​	5. 令

​		$v=xRmodn$

6. 若$v==r$,则验证签名有效,若$v\neq r$,则验证签名无效

     

## 二、运行结果

![image-20230804190139778](C:\Users\Lenovo\OneDrive\桌面\img\image-20230804190139778.png)

* 1.先引用一个库，导入比特币中固定的G，n等等（未找到中本聪的P=dG，故P取了一个随机值）
  2.设出u,v的值
  3.根据公式，建立数学关系，得到伪造的r，e，s满足对e=Hash(m)的验证。

  

